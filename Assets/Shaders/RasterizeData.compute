// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel RasterizeThickLines
#pragma kernel RasterizeGradients
#pragma kernel RasterizeLines
#pragma kernel RasterizeSplines
#pragma kernel RasterizeAverageGradients
#pragma kernel FillRestriction
#pragma kernel RasterizeAverageThickLines

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> result;
RWTexture2D<float4> normal;
RWTexture2D<float4> restriction;
RWTexture2D<float4> noise;

struct Line
{
    float2 v;
    float2 w;
    float h1;
    float h2;
};

StructuredBuffer<Line> lines;

struct Triangle
{
    float2 a;
    float2 b;
    float2 c;

    float4 c1;
    float4 c2;
    float4 c3;
};

StructuredBuffer<Triangle> triangles;


struct Spline
{
    float3 p1;
    float3 p2;
    float3 p3;
    float3 p4;
};

StructuredBuffer<Spline> splines;


StructuredBuffer<uint> indices;
StructuredBuffer<float3> vertices;
StructuredBuffer<float4> colors;

float textureDivTerrain;
float2 center;

///////////////////////
//
//  Util for dist between point and line
//
///////////////////////
float dist2(float2 v, float2 w)
{
    return pow(v.x - w.x, 2) + pow(v.y - w.y, 2);
}

float distToSegmentSquared(float2 p, float2 v, float2 w, out float t)
{
    float l2 = dist2(v, w);
    if (l2 == 0) return dist2(p, v);
    t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = clamp(t, 0, 1);
    return dist2(p, float2(v.x + t * (w.x - v.x), v.y + t * (w.y - v.y)));
}

float distToSegment(float2 p, float2 v, float2 w, out float t)
{
    return sqrt(distToSegmentSquared(p, v, w, t));
}


///////////////////////
//
//  Util for inside triangle check
//
///////////////////////

float3 barycentric(float2 aV1, float2 aV2, float2 aV3, float2 aP)
{
    float2 a = aV2 - aV3;
    float2 b = aV1 - aV3;
    float2 c = aP - aV3;
    float aLen = a.x * a.x + a.y * a.y;
    float bLen = b.x * b.x + b.y * b.y;
    float ab = a.x * b.x + a.y * b.y;
    float ac = a.x * c.x + a.y * c.y;
    float bc = b.x * c.x + b.y * c.y;
    float d = aLen * bLen - ab * ab;
    float u = (aLen * bc - ab * ac) / d;
    float v = (bLen * ac - ab * bc) / d;
    float w = 1.0f - u - v;
    return float3(u, v, w);
}

bool isInside(float3 uvw)
{
    float u = uvw.x;
    float v = uvw.y;
    float w = uvw.z;
    return (u >= 0.0f) && (u <= 1.0f) && (v >= 0.0f) && (v <= 1.0f) && (w >= 0.0f);
}

float4 colorFromBary(float3 uvw, float4 c1, float4 c2, float4 c3)
{
    return uvw.x * c1 + uvw.y * c2 + uvw.z * c3;
}

float2 vertexToWordspace(float3 vertex, float2 center, float WdivT)
{
    return (center + vertex.xz) * WdivT;
}

///////////////////////
//
//  Rasterize Gradients
//
///////////////////////

[numthreads(8, 8, 1)]
void RasterizeGradients(uint3 id : SV_DispatchThreadID)
{
    float4 res = float4(0, 0, 0, 1);
    int counter = 0;

    float2 p = id.xy + float2(0.5, 0.5);

    uint numOfStructs;
    uint stride;

    indices.GetDimensions(numOfStructs, stride);

    for (int n = 0; n < numOfStructs; n += 3)
    {
        float2 a = vertexToWordspace(vertices[indices[n]], center, textureDivTerrain);
        float2 b = vertexToWordspace(vertices[indices[n + 1]], center, textureDivTerrain);
        float2 c = vertexToWordspace(vertices[indices[n + 2]], center, textureDivTerrain);

        if (
            (p.x < a.x && p.x < b.x && p.x < c.x) ||
            (p.x > a.x && p.x > b.x && p.x > c.x) ||
            (p.y < a.y && p.y < b.y && p.y < c.y) ||
            (p.y > a.y && p.y > b.y && p.y > c.y)
        )
        {
            continue;
        }

        float3 bary = barycentric(
            a, b, c,
            p);

        if (isInside(bary) == true)
        {
            res = colorFromBary(bary, colors[indices[n]], colors[indices[n + 1]], colors[indices[n + 2]]);
            counter++;
        }
    }
    if (counter == 1)
    {
        result[id.xy] = res;
    }
}


///////////////////////
//
//  Rasterize ThickLines
//
///////////////////////

[numthreads(8, 8, 1)]
void RasterizeThickLines(uint3 id : SV_DispatchThreadID)
{
    float4 res = float4(0, 0, 0, 1);
    int counter = 0;

    float2 p = id.xy + float2(0.5, 0.5);
    uint numOfStructs;
    uint stride;

    indices.GetDimensions(numOfStructs, stride);

    for (int n = 0; n < numOfStructs; n += 3)
    {
        float2 a = vertexToWordspace(vertices[indices[n]], center, textureDivTerrain);
        float2 b = vertexToWordspace(vertices[indices[n + 1]], center, textureDivTerrain);
        float2 c = vertexToWordspace(vertices[indices[n + 2]], center, textureDivTerrain);

        if (
            (p.x < a.x && p.x < b.x && p.x < c.x) ||
            (p.x > a.x && p.x > b.x && p.x > c.x) ||
            (p.y < a.y && p.y < b.y && p.y < c.y) ||
            (p.y > a.y && p.y > b.y && p.y > c.y)
        )
        {
            continue;
        }

        float3 bary = barycentric(
            a, b, c,
            p);

        if (isInside(bary) == true)
        {
            res = colorFromBary(bary, colors[indices[n]], colors[indices[n + 1]], colors[indices[n + 2]]);
            counter++;
        }
    }
    if (counter == 1)
    {
        result[id.xy] = res;
    }
}


[numthreads(8, 8, 1)]
void RasterizeTriangles(uint3 id : SV_DispatchThreadID)
{
    float4 res = float4(0, 0, 0, 1);
    float tt = 0;
    int nn = 0;

    uint numOfStructs;
    uint stride;

    triangles.GetDimensions(numOfStructs, stride);

    for (int n = 0; n < numOfStructs; n++)
    {
        Triangle t = triangles[n];
        float3 bary = barycentric(t.a, t.b, t.c, id.xy);
        if (isInside(bary) == true)
        {
            res = colorFromBary(bary, t.c1, t.c2, t.c3);
        }
    }
    result[id.xy] = res;
}


[numthreads(8, 8, 1)]
void RasterizeLines(uint3 id : SV_DispatchThreadID)
{
    float res = 1;
    float tt = 0;
    int nn = 0;

    uint numOfStructs;
    uint stride;

    lines.GetDimensions(numOfStructs, stride);

    for (int n = 0; n < numOfStructs; n++)
    {
        // https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
        float t;
        float dist = distToSegment(id.xy, lines[n].v, lines[n].w, t);
        if (dist < res)
        {
            tt = t;
            nn = n;
            res = min(res, dist);
        }
    }

    res = clamp(1 - res, 0, 1);

    res = res * (tt * lines[nn].h2 + (1 - tt) * lines[nn].h1);

    result[id.xy] = float4(res, res, res, 1.0);
}


int width;
int height;
float maxHeight;

void handlePixel(int2 p, float err, float2 colors, int2 start, float distBetweenPoints, float2 perpendicular)
{
    const float distOnLine = distance(p, start);
    const float interpolatedHeight = colors.x + (colors.y - colors.x) * (distOnLine / distBetweenPoints);
    result[p] = float4(interpolatedHeight / maxHeight, 0, 0, 1);
    restriction[p] = float4(0, 0, 0, 1);

    float2 pt = floor(p + perpendicular * 1.5);
    if (pt.x > 0 && pt.y > 0 && pt.x < width && pt.y < height)
    {
        normal[pt] = float4((1.0 + perpendicular) / 2.0, normal[pt].z, 1);
    }
    float2 pt2 = floor(p - perpendicular * 1.5);
    if (pt2.x > 0 && pt2.y > 0 && pt2.x < width && pt2.y < height)
    {
        normal[pt2] = float4((1 - perpendicular) / 2, normal[pt2].z, 1);
    }
}

void pixelsOfAntiAliasedLine(int x0, int y0, int x1, int y1, float2 colors, float2 perpendicular)
{
    const float distBetweenPoints = distance(int2(x0, y0), int2(x1, y1));

    const int dx = abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
    const int dy = abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
    int x2, e2, err = dx - dy; /* error value e_xy */
    const int ed = dx + dy == 0 ? 1 : ((int)sqrt((float)dx * dx + (float)dy * dy));
    for (; ;)
    {
        /* pixel loop */
        handlePixel(int2(x0, y0), 255 * abs(err - dx + dy) / ed, colors, int2(x0, y0), distBetweenPoints,
                    perpendicular);
        e2 = err;
        x2 = x0;
        if (2 * e2 >= -dx)
        {
            /* x step */
            if (x0 == x1) break;
            if (e2 + dy < ed)
                handlePixel(int2(x0, y0 + sy), 255 * (e2 + dy) / ed, colors, int2(x0, y0),
                            distBetweenPoints, perpendicular);
            err -= dy;
            x0 += sx;
        }
        if (2 * e2 <= dy)
        {
            /* y step */
            if (y0 == y1) break;
            if (dx - e2 < ed)
                handlePixel(int2(x2 + sx, y0), 255 * (dx - e2) / ed, colors, int2(x0, y0),
                            distBetweenPoints, perpendicular);
            err += dx;
            y0 += sy;
        }
    }
}


float3 GetPoint(float3 p0, float3 p1, float3 p2, float3 p3, float t)
{
    t = clamp(t, 0, 1);
    float oneMinusT = 1.0 - t;
    return
        oneMinusT * oneMinusT * oneMinusT * p0 +
        3.0 * oneMinusT * oneMinusT * t * p1 +
        3.0 * oneMinusT * t * t * p2 +
        t * t * t * p3;
}

float4x4 localToWorld;
float3 position;

[numthreads(8, 8, 1)]
void RasterizeSplines(uint3 id : SV_DispatchThreadID)
{
    Spline spline = splines[id.x];
    float3 p1 = spline.p1;
    float3 p2 = spline.p2;
    float3 p3 = spline.p3;
    float3 p4 = spline.p4;

    float3 oppt = mul(float4(GetPoint(p1, p2, p3, p4, 0), 1), localToWorld).xyz + position;
    for (float r = 0.01; r <= 1; r += 0.01)
    {
        float3 ppt = mul(float4(GetPoint(p1, p2, p3, p4, r), 1), localToWorld).xyz + position;

        const int2 a = round(vertexToWordspace(oppt, center, textureDivTerrain));
        const int2 b = round(vertexToWordspace(ppt, center, textureDivTerrain));

        const float2 tinyLiny = (a - b).xy;
        const float2 perpendicular = normalize(float2(tinyLiny.y, -tinyLiny.x));

        pixelsOfAntiAliasedLine(a.x, a.y, b.x, b.y, float2(oppt.y, ppt.y), perpendicular);
        oppt = ppt;
    }
}

float4 gradientColorStart;
float4 gradientColorEnd;

[numthreads(8,1,1)]
void RasterizeAverageGradients(uint3 id : SV_DispatchThreadID)
{
    const int n = id.x * 3;

    const float2 a = vertexToWordspace(vertices[indices[n]], center, textureDivTerrain);
    const float2 b = vertexToWordspace(vertices[indices[n + 1]], center, textureDivTerrain);
    const float2 c = vertexToWordspace(vertices[indices[n + 2]], center, textureDivTerrain);

    const int minx = floor(max(0, min(a.x, min(b.x, c.x))));
    const int miny = floor(max(0, min(a.y, min(b.y, c.y))));
    const int maxx = ceil(min(width, max(a.x, max(b.x, c.x))));
    const int maxy = ceil(min(height, max(a.y, max(b.y, c.y))));

    for (int x = minx; x < maxx; x += 1)
    {
        for (int y = miny; y < maxy; y += 1)
        {
            float2 p = float2(x + 0.5f, y + 0.5f);

            float3 bary = barycentric(
                a, b, c,
                p);

            if (isInside(bary) == true)
            {
                float4 oldNormal = normal[float2(x, y)];
                if (oldNormal.z == 0)
                {
                    float4 normalColor = colorFromBary(bary, colors[indices[n]], colors[indices[n + 1]],
                                                       colors[indices[n + 2]]);
                    normal[float2(x, y)] = float4(oldNormal.xy, normalColor.z, oldNormal.w);
                }
                else
                {
                    normal[float2(x, y)] = float4(oldNormal.xy, 0, oldNormal.w);
                }

                if (restriction[float2(x, y)].w == 0)
                {
                    const float3 odd = float3(indices[n] % 2 == 0, indices[n + 1] % 2 == 0, indices[n + 2] % 2 == 0);
                    const float4 color1 = gradientColorEnd * (1 - odd.x) + gradientColorStart * odd.x;
                    const float4 color2 = gradientColorEnd * (1 - odd.y) + gradientColorStart * odd.y;
                    const float4 color3 = gradientColorEnd * (1 - odd.z) + gradientColorStart * odd.z;

                    restriction[float2(x, y)] = colorFromBary(bary,
                                                              color1,
                                                              color2,
                                                              color3);;
                }
            }
        }
    }
}

[numthreads(8,1,1)]
void RasterizeAverageThickLines(uint3 id : SV_DispatchThreadID)
{
    const int n = id.x * 3;

    const float2 a = vertexToWordspace(vertices[indices[n]], center, textureDivTerrain);
    const float2 b = vertexToWordspace(vertices[indices[n + 1]], center, textureDivTerrain);
    const float2 c = vertexToWordspace(vertices[indices[n + 2]], center, textureDivTerrain);

    const int minx = floor(max(0, min(a.x, min(b.x, c.x))));
    const int miny = floor(max(0, min(a.y, min(b.y, c.y))));
    const int maxx = ceil(min(width, max(a.x, max(b.x, c.x))));
    const int maxy = ceil(min(height, max(a.y, max(b.y, c.y))));

    for (int x = minx; x < maxx; x += 1)
    {
        for (int y = miny; y < maxy; y += 1)
        {
            float2 p = float2(x + 0.5f, y + 0.5f);

            float3 bary = barycentric(
                a, b, c,
                p);

            if (isInside(bary) == true)
            {
                float4 color = colorFromBary(bary, colors[indices[n]], colors[indices[n + 1]],
                                                   colors[indices[n + 2]]);
                result[float2(x, y)] = color;

                restriction[float2(x, y)] = float4(0,0,0,1);
            }
        }
    }
}

[numthreads(8,8,1)]
void FillRestriction(uint3 id : SV_DispatchThreadID)
{
    restriction[id.xy] = restriction[id.xy] * restriction[id.xy].w + float4(1,0,0,1) * (1-restriction[id.xy].w); 
}    