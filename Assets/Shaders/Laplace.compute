// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TerrainRelaxation
#pragma kernel Relaxation
#pragma kernel Restrict
#pragma kernel Interpolate
#pragma kernel Smooth
#pragma kernel SmoothKernel
#pragma kernel RestrictedSmoothing
#pragma kernel SumTwoTextures
#pragma kernel NormalizeNormals

RWTexture2D<float4> result;

RWTexture2D<float4> seedTexture;

int image_size;

float4 getPixel(RWTexture2D<float4> tex, uint2 pixel)
{
    /*if (tex[pixel].w != 1) {
        return tex[pixel] / tex[pixel].w;
    }*/
    return tex[pixel];
}

float4 inpToNorm(float4 val)
{
    return (0.5 - val) * 2;
}

float4 normToInp(float4 val)
{
    return (1 + val) / 2;
}

float applySeed(uint2 pixel, RWTexture2D<float4> result, RWTexture2D<float4> seedTexture)
{
    if (seedTexture[pixel].x == 0 && seedTexture[pixel].y == 0 && seedTexture[pixel].z == 0)
    {
        return result[pixel];
    }
    return seedTexture[pixel];
}

float applySeed(uint2 pixel, RWTexture2D<float> result, RWTexture2D<float4> seedTexture)
{
    if (seedTexture[pixel].x == 0 && seedTexture[pixel].y == 0 && seedTexture[pixel].z == 0)
    {
        return result[pixel];
    }
    return seedTexture[pixel];
}


[numthreads(4, 4, 1)]
void Relaxation(uint3 id : SV_DispatchThreadID)
{
    float3 res = float3(0, 0, 0);

    if (seedTexture[id.xy].w == 1 || seedTexture[id.xy].w == 3)    {
        res.xy = seedTexture[id.xy].xy;
    }
    else
    {
        res.xy = (
                (id.x == 0 ? 0 : result[id.xy - uint2(1, 0)])
                + (id.y == 0 ? 0 : result[id.xy - uint2(0, 1)])
                + (id.x == image_size - 1 ? 0 : result[id.xy - uint2(-1, 0)])
                + (id.y == image_size - 1 ? 0 : result[id.xy - uint2(0, -1)])
            ).xy
            / ((id.x == 0 ? 0 : 1) + (id.y == 0 ? 0 : 1) + (id.x == image_size - 1 ? 0 : 1) + (
                id.y == image_size - 1 ? 0 : 1));
    }

    if (seedTexture[id.xy].w == 2 || seedTexture[id.xy].w == 3)
    {
        res.z = seedTexture[id.xy].z;
    }
    else
    {
        res.z = (
                (id.x == 0 ? 0 : result[id.xy - uint2(1, 0)])
                + (id.y == 0 ? 0 : result[id.xy - uint2(0, 1)])
                + (id.x == image_size - 1 ? 0 : result[id.xy - uint2(-1, 0)])
                + (id.y == image_size - 1 ? 0 : result[id.xy - uint2(0, -1)])
            ).z
            / ((id.x == 0 ? 0 : 1) + (id.y == 0 ? 0 : 1) + (id.x == image_size - 1 ? 0 : 1) + (
                id.y == image_size - 1 ? 0 : 1));
    }

    result[id.xy] = float4(res, 1);
}

RWTexture2D<float4> restrictionsTexture;
RWTexture2D<float4> normals;

RWTexture2D<float4> terrainHeight;
Texture2D<float4> redGreenBlack;

float4 getTerrainHeight(uint2 pos)
{
    return restrictionsTexture[pos].x + restrictionsTexture[pos].y < 0.9 ? seedTexture[pos] : terrainHeight[pos];
}

bool runRed;
bool useRedBlack;

[numthreads(4, 4, 1)]
void TerrainRelaxationNormal(uint3 id : SV_DispatchThreadID)
{
    const float alpha = restrictionsTexture[id.xy].x;
    const float beta = restrictionsTexture[id.xy].y;

    //float2 normal = (0.5 - normals[id.xy].xy);
    //float gradient = (0.5 - normals[id.xy].z);
    const float2 normal = (normals[id.xy].xy);
    const float gradient = (normals[id.xy].z);

    // It crashes it normalize is run on (0,0) vector
    //normal = length(normal) > 0 ? normalize(normal) : float2(1, 0);
    const float Ll = (
            (id.x == 0
                 ? 0
                 : getTerrainHeight(id.xy - uint2(1, 0)))
            + (id.y == 0
                   ? 0
                 : getTerrainHeight(id.xy - uint2(0,1)))

            + (id.y == image_size - 1
                   ? 0
                 : getTerrainHeight(id.xy - uint2(0,-1)))

            + (id.x == image_size - 1
                   ? 0
                 : getTerrainHeight(id.xy - uint2(-1,0)))
        ).x
        / ((id.x == 0 ? 0 : 1) + (id.y == 0 ? 0 : 1) + (id.x == image_size - 1 ? 0 : 1) + (
            id.y == image_size - 1 ? 0 : 1));

    const float Ll2 = 0.25 * (
        terrainHeight[id.xy - uint2(0, 1)] +
        terrainHeight[id.xy - uint2(1, 0)] +
        terrainHeight[id.xy - uint2(-1, 0)] +
        terrainHeight[id.xy - uint2(0, -1)]);

    const float Lg = (
        pow(normal.x, 2) * getTerrainHeight(id.xy + int2(sign(normal.x), 0)) + //terrainHeight[id.xy + int2(sign(normal.x), 0)] +
        pow(normal.y, 2) * getTerrainHeight(id.xy + int2(0, sign(normal.y))) + //terrainHeight[id.xy + int2(0, sign(normal.y))] +
        gradient
    ) ;

    const float Li = seedTexture[id.xy].x;

    terrainHeight[id.xy] =
        float4((Ll) * alpha + (Lg) * beta + Li * (1 - alpha - beta), 0, 0, 1);
}


StructuredBuffer<int> kernel;
int kernelSize;

bool doubleDerivative;

[numthreads(4, 4, 1)]
void TerrainRelaxation(uint3 id : SV_DispatchThreadID)
{
    const float alpha = restrictionsTexture[id.xy].x;
    const float beta = restrictionsTexture[id.xy].y;

    //float2 normal = (0.5 - normals[id.xy].xy);
    //float gradient = (0.5 - normals[id.xy].z);
    const float2 normal = normalize(length(0.5 - normals[id.xy].xy) != 0 ? normalize(0.5 - normals[id.xy].xy) : float2(0, 1));
    const float gradient = (0.5-normals[id.xy].z);

    float Ll = 0;
    float div = 0;

    for(int x = -kernelSize; x <= kernelSize; x++)
    {
        for(int y = -kernelSize; y <= kernelSize; y++)
        {
            const int2 pos = id.xy + int2(x, y);
            if (pos.x < 0 || pos.y < 0 || pos.x >= image_size || pos.y >= image_size)
            {
                continue;
            }
            Ll += getTerrainHeight(pos) * kernel[x + kernelSize + (y + kernelSize)*(kernelSize*2+1)];
            div += kernel[x + kernelSize + (y + kernelSize)*(kernelSize*2+1)];
        }
    }
    if (div != 0)
    {
        Ll /= abs(div);
    }

    // It crashes it normalize is run on (0,0) vector
    //normal = length(normal) > 0 ? normalize(normal) : float2(1, 0);
    /*
    const float Ll = (
            (id.x == 0
                 ? 0
                 : getTerrainHeight(id.xy - uint2(1, 0)))
            + (id.y == 0
                   ? 0
                 : getTerrainHeight(id.xy - uint2(0,1)))

            + (id.y == image_size - 1
                   ? 0
                 : getTerrainHeight(id.xy - uint2(0,-1)))

            + (id.x == image_size - 1
                   ? 0
                 : getTerrainHeight(id.xy - uint2(-1,0)))
        ).x
        / ((id.x == 0 ? 0 : 1) + (id.y == 0 ? 0 : 1) + (id.x == image_size - 1 ? 0 : 1) + (
            id.y == image_size - 1 ? 0 : 1));
    */
    const float Ll2 = 0.25 * (
        terrainHeight[id.xy - uint2(0, 1)] +
        terrainHeight[id.xy - uint2(1, 0)] +
        terrainHeight[id.xy - uint2(-1, 0)] +
        terrainHeight[id.xy - uint2(0, -1)]);

    const float Lg = (
        pow(normal.x, 2) * (getTerrainHeight(id.xy + int2(sign(normal.x), 0)) * 0.7 + 0.3 * getTerrainHeight(id.xy + 2*int2(sign(normal.x), 0))) +
        pow(normal.y, 2) * (getTerrainHeight(id.xy + int2(0, sign(normal.y))) * 0.7 + 0.3 * getTerrainHeight(id.xy + 2*int2(0, sign(normal.y)))) +
        //pow(normal.y, 2) * getTerrainHeight(id.xy + int2(0, sign(normal.y))) + //terrainHeight[id.xy + int2(0, sign(normal.y))] +
        gradient
    );

    const float Li = seedTexture[id.xy].x;

    terrainHeight[id.xy] = float4( max(0, (terrainHeight[id.xy].x + 0.001 * Ll) * alpha + Lg * beta + Li * (1 - alpha - beta)), 0, 0, 1);
}


[numthreads(8, 8, 1)]
void NormalizeNormals(uint3 id : SV_DispatchThreadID)
{
    float z = 0.25 * (
        normals[id.xy - uint2(0, 1)] +
        normals[id.xy - uint2(1, 0)] +
        normals[id.xy - uint2(-1, 0)] +
        normals[id.xy - uint2(0, -1)]).z;
    result[id.xy] = float4(length(0.5 - normals[id.xy].xy) != 0 ? normalize(0.5 - normals[id.xy].xy) : float2(1, 0),
                           0.5 - z, 1);
}


RWTexture2D<float4> input1;
RWTexture2D<float4> input2;
float input1_weight;
float input2_weight;
float input1_bias;
float input2_bias;

[numthreads(8, 8, 1)]
void SumTwoTextures(uint3 id : SV_DispatchThreadID)
{
    result[id.xy] = input1_weight * (input1[id.xy] + input1_bias) + input2_weight * (input2[id.xy] + input2_bias);
}


RWTexture2D<float4> image;

[numthreads(8, 8, 1)]
void Restrict(uint3 id : SV_DispatchThreadID)
{
    uint2 center = uint2(id.x * 2, id.y * 2);

    float4 res = 0;
    float normalize = 0;
    float3x3 kernel = float3x3(float3(0.25, 0.5, 0.25), float3(0.5, 1, 0.5), float3(0.25, 0.5, 0.25));

    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            if (
                center.x + x >= 0 && center.x + x <= image_size * 2 &&
                center.y + y >= 0 && center.y + y <= image_size * 2
            )
            {
                res = res + kernel[x + 1][y + 1] * image[uint2(center.x + x, center.y + y)];
                normalize += kernel[x + 1][y + 1];
            }
        }
    }
    result[id.xy] = res / normalize;
}


[numthreads(8, 8, 1)]
void Interpolate(uint3 id : SV_DispatchThreadID)
{
    const uint2 center = uint2(id.x / 2, id.y / 2);

    /*

    How to propperly apply the filter in reverse
    Use modulo to figure out what pixels to interpolate from because I cannot use BLEND to sum the results

    */
    const float3 color = redGreenBlack[id.xy % 1024];

    // if r == 1 && g == 1
    // result[id.xy] = (image[center.xy] + image[center.xy + uint2(1, 0)] + image[center.xy + uint2(0, 1)] + image[center.xy + uint2(1, 1)]) / 4;
    // if r == 1 && g == 0
    // result[id.xy] = (image[center.xy] + image[center.xy + uint2(1, 0)]) / 2;
    // if r == 0 && g == 1
    // result[id.xy] = (image[center.xy] + image[center.xy + uint2(0, 1)]) / 2;
    // if r == 0 && g == 0
    // result[id.xy] = image[center.xy];
    
    //result[id.xy] = float4(id.x % 2, id.y % 2, 0, 1);
    //return;

    result[id.xy] = (
        image[center.xy]
        + image[center.xy + uint2(1, 0)] * color.r
        + image[center.xy + uint2(0, 1)] * color.g
        + image[center.xy + uint2(1, 1)] * color.r * color.g
    ) / (1 + color.r + color.g + color.r * color.g);
    return;

    if (id.x % 2 == 1)
    {
        // Interpolate between two values in x
        if (id.y % 2 == 1)
        {
            // Interpolate between two values in y
            result[id.xy] = (image[center.xy] + image[center.xy + uint2(1, 0)] + image[center.xy + uint2(0, 1)] + image[
                center.xy + uint2(1, 1)]) / 4;
            return;
        }
        if (id.y % 2 == 0)
        {
            // On a clear value in the y direction
            result[id.xy] = (image[center.xy] + image[center.xy + uint2(1, 0)]) / 2;
            return;
        }
    }
    if (id.x % 2 == 0)
    {
        // On a clear value in the x direction
        if (id.y % 2 == 1)
        {
            // Interpolate between two values in y
            result[id.xy] = (image[center.xy] + image[center.xy + uint2(0, 1)]) / 2;
            return;
        }
        if (id.y % 2 == 0)
        {
            // On a clear value in the y direction
            result[id.xy] = image[center.xy];
            return;
        }
    }
}


[numthreads(8, 8, 1)]
void Smooth(uint3 id : SV_DispatchThreadID)
{
    result[id.xy] = 0.25 * (
        result[id.xy - uint2(0, 1)] +
        result[id.xy - uint2(1, 0)] +
        result[id.xy - uint2(-1, 0)] +
        result[id.xy - uint2(0, -1)]);
}
[numthreads(8, 8, 1)]
void SmoothKernel(uint3 id : SV_DispatchThreadID)
{
    
    float Ll = 0;
    float div = 0;

    for(int x = -kernelSize; x <= kernelSize; x++)
    {
        for(int y = -kernelSize; y <= kernelSize; y++)
        {
            const int2 pos = id.xy + int2(x, y);
            if (pos.x < 0 || pos.y < 0 || pos.x >= image_size || pos.y >= image_size)
            {
                continue;
            }
            Ll += result[pos] * kernel[x + kernelSize + (y + kernelSize)*(kernelSize*2+1)];
            div += kernel[x + kernelSize + (y + kernelSize)*(kernelSize*2+1)];
        }
    }
    Ll /= div;
    result[id.xy] = Ll;
}


[numthreads(8, 8, 1)]
void RestrictedSmoothing(uint3 id : SV_DispatchThreadID)
{
    result[id.xy] = (seedTexture[id.xy].x > 0 ? 1 : 0) * 0.25 * (
            result[id.xy - uint2(0, 1)] +
            result[id.xy - uint2(1, 0)] +
            result[id.xy - uint2(-1, 0)] +
            result[id.xy - uint2(0, -1)])
        +
        (seedTexture[id.xy].x > 0 ? 0 : 1) * result[id.xy];
}
