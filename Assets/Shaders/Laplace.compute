// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TerrainRelaxation
#pragma kernel Relaxation
#pragma kernel Restrict
#pragma kernel Interpolate
#pragma kernel Smooth
#pragma kernel RestrictedSmoothing
#pragma kernel SumTwoTextures

RWTexture2D<float4> result;

RWTexture2D<float4> seedTexture;

int image_size;

float4 getPixel(RWTexture2D<float4> tex, uint2 pixel) {
    /*if (tex[pixel].w != 1) {
        return tex[pixel] / tex[pixel].w;
    }*/
    return tex[pixel];
}

float4 inpToNorm(float4 val) {
    return (0.5 - val) * 2;
}
float4 normToInp(float4 val) {
    return (1 + val) / 2;
}

float applySeed(uint2 pixel, RWTexture2D<float4> result, RWTexture2D<float4> seedTexture) {
    if (seedTexture[pixel].x == 0 && seedTexture[pixel].y == 0 && seedTexture[pixel].z == 0) {
        return result[pixel];
    }
    return seedTexture[pixel];
}
float applySeed(uint2 pixel, RWTexture2D<float> result, RWTexture2D<float4> seedTexture) {
    if (seedTexture[pixel].x == 0 && seedTexture[pixel].y == 0 && seedTexture[pixel].z == 0) {
        return result[pixel];
    }
    return seedTexture[pixel];
}


[numthreads(8, 8, 1)]
void Relaxation(uint3 id : SV_DispatchThreadID)
{
    float3 res = float3(0, 0, 0);

    if (seedTexture[id.xy].w > 0) {
        res.xy = seedTexture[id.xy].xy;
    }
    else
    {
        res.xy = (
            (id.x == 0 ? 0 : result[id.xy - uint2(1, 0)])
            + (id.y == 0 ? 0 : result[id.xy - uint2(0, 1)])
            + (id.x == image_size - 1 ? 0 : result[id.xy - uint2(-1, 0)])
            + (id.y == image_size-1 ? 0 : result[id.xy - uint2(0, -1)])
            ).xy
            / ((id.x == 0 ? 0 : 1) + (id.y == 0 ? 0 : 1) + (id.x == image_size - 1 ? 0 : 1) + (id.y == image_size - 1 ? 0 : 1));
    }

    if (seedTexture[id.xy].z > 0.1) {
        res.z = seedTexture[id.xy].z;
    }
    else {
        res.z = (
            (id.x == 0 ? 0 : result[id.xy - uint2(1, 0)])
            + (id.y == 0 ? 0 : result[id.xy - uint2(0, 1)])
            + (id.x == image_size - 1 ? 0 : result[id.xy - uint2(-1, 0)])
            + (id.y == image_size - 1 ? 0 : result[id.xy - uint2(0, -1)])
            ).z
            / ((id.x == 0 ? 0 : 1) + (id.y == 0 ? 0 : 1) + (id.x == image_size - 1 ? 0 : 1) + (id.y == image_size - 1 ? 0 : 1));
/*        res.z = (float4(0.25 * (
            (result[id.xy - uint2(0, 1)]) +
            (result[id.xy - uint2(1, 0)]) +
            (result[id.xy - uint2(-1, 0)]) +
            (result[id.xy - uint2(0, -1)])
            ))).z;
            */
    }

    result[id.xy] = float4(res, 1);
}


RWTexture2D<float4> restrictionsTexture;
RWTexture2D<float4> normals;

RWTexture2D<float> terrainHeight;

[numthreads(8, 8, 1)]
void TerrainRelaxation(uint3 id : SV_DispatchThreadID)
{
    float2 normal = (0.5 - normals[id.xy].xy);
    float gradient = (0.5-normals[id.xy].z);

    // It crashes it normalize is run on (0,0) vector
    if (normal.x != 0 && normal.y != 0) {
        normal = normalize(normal);
    }

    if (restrictionsTexture[id.xy].x == 0) {
        terrainHeight[id.xy] = seedTexture[id.xy].x * (1 - restrictionsTexture[id.xy].x - restrictionsTexture[id.xy].y);
    }
    else {
        terrainHeight[id.xy] = 
            (
                ((id.x == 0 ? 0 : terrainHeight[id.xy - uint2(1, 0)])
                + (id.y == 0 ? 0 : terrainHeight[id.xy - uint2(0, 1)])
                + (id.x == image_size - 1 ? 0 : terrainHeight[id.xy - uint2(-1, 0)])
                + (id.y == image_size - 1 ? 0 : terrainHeight[id.xy - uint2(0, -1)])
                )
                / ((id.x == 0 ? 0 : 1) + (id.y == 0 ? 0 : 1) + (id.x == image_size - 1 ? 0 : 1) + (id.y == image_size - 1 ? 0 : 1))
            ) * restrictionsTexture[id.xy].x +
            (
                pow(normal.x, 2) * terrainHeight[id.xy + int2(sign(normal.x), 0)] +
                pow(normal.y, 2) * terrainHeight[id.xy + int2(0, sign(normal.y))] +
                gradient
            )
            * restrictionsTexture[id.xy].y;
    }
    return;


    // Get the gradient saved in normals

    float res = 
        // Calculate the average and use the weight
        0.25 * (
            terrainHeight[id.xy - uint2(0, 1)] +
            terrainHeight[id.xy - uint2(1, 0)] +
            terrainHeight[id.xy - uint2(-1, 0)] +
            terrainHeight[id.xy - uint2(0, -1)])
        * restrictionsTexture[id.xy].x
        +
        // Calculate the height of the neighbour and add the gradient and weigh it
        (
            pow(normal.x, 2) * terrainHeight[id.xy + int2(sign(normal.x), 0)] +
            pow(normal.y, 2) * terrainHeight[id.xy + int2(0, sign(normal.y))] +
            gradient
        )
        * restrictionsTexture[id.xy].y
        +
        // Identity, take itself and weigh it
        seedTexture[id.xy].x
        * (1 - restrictionsTexture[id.xy].x - restrictionsTexture[id.xy].y);

    terrainHeight[id.xy] = res;
}


RWTexture2D<float4> input1;
RWTexture2D<float4> input2;
float input1_weight;
float input2_weight;
float input1_bias;
float input2_bias;
[numthreads(8, 8, 1)]
void SumTwoTextures(uint3 id : SV_DispatchThreadID)
{
    result[id.xy] = input1_weight * (input1[id.xy] + input1_bias) + input2_weight * (input2[id.xy] + input2_bias);
}




RWTexture2D<float4> image;

[numthreads(8, 8, 1)]
void Restrict(uint3 id : SV_DispatchThreadID)
{
    uint2 center = uint2(id.x * 2, id.y * 2);

    float4 res = 0;
    float normalize = 0;
    float3x3 kernel = float3x3(float3(0.25, 0.5, 0.25), float3(0.5, 1, 0.5), float3(0.25, 0.5, 0.25));

    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            if (
                center.x + x >= 0 && center.x + x <= image_size * 2 &&
                center.y + y >= 0 && center.y + y <= image_size * 2
                ) {
                res = res + kernel[x + 1][y + 1] * image[uint2(center.x + x, center.y + y)];
                normalize += kernel[x + 1][y + 1];
            }
        }
    }
    result[id.xy] = res / normalize;
}

[numthreads(8, 8, 1)]
void Interpolate(uint3 id : SV_DispatchThreadID)
{
    uint2 center = uint2(id.x / 2, id.y / 2);

    /*

    How to propperly apply the filter in reverse
    Use modulo to figure out what pixels to interpolate from because I cannot use BLEND to sum the results

    */

    //if (1 == image_size) {
    //    result[id.xy] = image[uint2(0, 0)];
    //    return;
    //}

    if (1 == 1) {
        if (id.x % 2 == 1) {
            // Interpolate between two values in x
            if (id.y % 2 == 1) {
                // Interpolate between two values in y
                result[id.xy] = (image[center.xy] + image[center.xy + uint2(1, 0)] + image[center.xy + uint2(0, 1)] + image[center.xy + uint2(1, 1)]) / 4;
                return;
            }
            if (id.y % 2 == 0) {
                // On a clear value in the y direction
                result[id.xy] = (image[center.xy] + image[center.xy + uint2(1, 0)]) / 2;
                return;
            }
        }
        if (id.x % 2 == 0) {
            // On a clear value in the x direction
            if (id.y % 2 == 1) {
                // Interpolate between two values in y
                result[id.xy] =(image[center.xy] + image[center.xy + uint2(0, 1)]) / 2;
                return;
            }
            if (id.y % 2 == 0) {
                // On a clear value in the y direction
                result[id.xy] = image[center.xy];
                return;
            }
        }
    }

    if (id.x % 2 == 1) {
        // Interpolate between two values in x
        if (id.y % 2 == 1) {
            // Interpolate between two values in y
            result[id.xy] = (result[id.xy] + (image[center.xy] + image[center.xy + uint2(1, 0)] + image[center.xy + uint2(0, 1)] + image[center.xy + uint2(1, 1)]) / 4) / 2;
            return;
        }
        if (id.y % 2 == 0) {
            // On a clear value in the y direction
            result[id.xy] = (result[id.xy] + (image[center.xy] + image[center.xy + uint2(1, 0)]) / 2) / 2;
            return;
        }
    }
    if (id.x % 2 == 0) {
        // On a clear value in the x direction
        if (id.y % 2 == 1) {
            // Interpolate between two values in y
            result[id.xy] = (result[id.xy] + (image[center.xy] + image[center.xy + uint2(0, 1)]) / 2) / 2;
            return;
        }
        if (id.y % 2 == 0) {
            // On a clear value in the y direction
            result[id.xy] = (result[id.xy] + image[center.xy]) / 2;
            return;
        }
    }
    result[id.xy] = result[id.xy];

}


[numthreads(8, 8, 1)]
void Smooth(uint3 id : SV_DispatchThreadID)
{
    result[id.xy] = (1 - restrictionsTexture[id.xy].x) * 0.25 * (
        result[id.xy - uint2(0, 1)] +
        result[id.xy - uint2(1, 0)] +
        result[id.xy - uint2(-1, 0)] +
        result[id.xy - uint2(0, -1)]);
}


[numthreads(8, 8, 1)]
void RestrictedSmoothing(uint3 id : SV_DispatchThreadID)
{
    result[id.xy] = (seedTexture[id.xy].x > 0 ? 1 : 0) * 0.25 * (
        result[id.xy - uint2(0, 1)] +
        result[id.xy - uint2(1, 0)] +
        result[id.xy - uint2(-1, 0)] +
        result[id.xy - uint2(0, -1)])
        +
        (seedTexture[id.xy].x > 0 ? 0 : 1) * result[id.xy]
        ;
}

