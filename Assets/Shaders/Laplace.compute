// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TerrainRelaxation
#pragma kernel Relaxation
#pragma kernel Restrict
#pragma kernel Interpolate

RWTexture2D<float4> result;

RWTexture2D<float4> seedTexture;

float4 getPixel(RWTexture2D<float4> tex, uint2 pixel) {
    /*if (tex[pixel].w != 1) {
        return tex[pixel] / tex[pixel].w;
    }*/
    return tex[pixel];
}

float4 inpToNorm(float4 val) {
    return (0.5 - val) * 2;
}
float4 normToInp(float4 val) {
    return (1 + val) / 2;
}

float applySeed(uint2 pixel, RWTexture2D<float4> result, RWTexture2D<float4> seedTexture) {
    if (seedTexture[pixel].x == 0 && seedTexture[pixel].y == 0 && seedTexture[pixel].z == 0) {
        return result[pixel];
    }
    return seedTexture[pixel];
}
float applySeed(uint2 pixel, RWTexture2D<float> result, RWTexture2D<float4> seedTexture) {
    if (seedTexture[pixel].x == 0 && seedTexture[pixel].y == 0 && seedTexture[pixel].z == 0) {
        return result[pixel];
    }
    return seedTexture[pixel];
}


[numthreads(8, 8, 1)]
void Relaxation(uint3 id : SV_DispatchThreadID)
{
    float3 res = float3(0, 0, 0);

    if (seedTexture[id.xy].w == 1) {
        res.xy = seedTexture[id.xy].xy;
    }
    else {
        res.xy = (float4(0.25 * (
            (result[id.xy - uint2(0, 1)]) +
            (result[id.xy - uint2(1, 0)]) +
            (result[id.xy - uint2(-1, 0)]) +
            (result[id.xy - uint2(0, -1)])
            ))).xy;
    }

    if (seedTexture[id.xy].z != 0) {
        res.z = seedTexture[id.xy].z;
    }
    else {
        res.z = (float4(0.25 * (
            (result[id.xy - uint2(0, 1)]) +
            (result[id.xy - uint2(1, 0)]) +
            (result[id.xy - uint2(-1, 0)]) +
            (result[id.xy - uint2(0, -1)])
            ))).z;
    }

    result[id.xy] = float4(res, 1);
}


RWTexture2D<float4> restrictionsTexture;
RWTexture2D<float4> normals;

RWTexture2D<float> terrainHeight;

[numthreads(8, 8, 1)]
void TerrainRelaxation(uint3 id : SV_DispatchThreadID)
{
    float2 normal = (0.5 - normals[id.xy].xy);
    // It crashes it normalize is run on (0,0) vector
    if (normal.x != 0 && normal.y != 0) {
        normal = normalize(normal);
    }
    // Get the gradient saved in normals
    float gradient = (0.5-normals[id.xy].z);

    float res = 
        // Calculate the average and use the weight
        0.25 * (
            terrainHeight[id.xy - uint2(0, 1)] +
            terrainHeight[id.xy - uint2(1, 0)] +
            terrainHeight[id.xy - uint2(-1, 0)] +
            terrainHeight[id.xy - uint2(0, -1)])
        * restrictionsTexture[id.xy].x
        +
        // Calculate the height of the neighbour and add the gradient and weigh it
        (
            pow(normal.x, 2) * terrainHeight[id.xy + int2(sign(normal.x), 0)] +
            pow(normal.y, 2) * terrainHeight[id.xy + int2(0, sign(normal.y))] +
            gradient
        )
        * restrictionsTexture[id.xy].y
        +
        // Identity, take itself and weigh it
        seedTexture[id.xy].x
        * (1 - restrictionsTexture[id.xy].x - restrictionsTexture[id.xy].y);

    terrainHeight[id.xy] = res;
}










RWTexture2D<float4> image;
int image_size;


[numthreads(8, 8, 1)]
void Restrict(uint3 id : SV_DispatchThreadID)
{
    uint2 center = uint2(id.x * 2, id.y * 2);

    float4 res = 0;
    float normalize = 0;
    float3x3 kernel = float3x3(float3(0.25, 0.5, 0.25), float3(0.5, 1, 0.5), float3(0.25, 0.5, 0.25));

    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            if (
                center.x + x >= 0 && center.x + x <= image_size * 2 &&
                center.y + y >= 0 && center.y + y <= image_size * 2
                ) {
                res = res + kernel[x + 1][y + 1] * image[uint2(center.x + x, center.y + y)];
                normalize += kernel[x + 1][y + 1];
            }
        }
    }
    result[id.xy] = res / normalize;
}

[numthreads(8, 8, 1)]
void Interpolate(uint3 id : SV_DispatchThreadID)
{
    uint2 center = uint2(id.x / 2, id.y / 2);

    /*

    How to propperly apply the filter in reverse
    Use modulo to figure out what pixels to interpolate from because I cannot use BLEND to sum the results

    */

    if (3 == image_size) {
        result[id.xy] = image[uint2(0, 0)];
        return;
    }

    if (1 == 1) {
        if (id.x % 2 == 1) {
            // Interpolate between two values in x
            if (id.y % 2 == 1) {
                // Interpolate between two values in y
                result[id.xy] = (image[center.xy] + image[center.xy + uint2(1, 0)] + image[center.xy + uint2(0, 1)] + image[center.xy + uint2(1, 1)]) / 4;
                return;
            }
            if (id.y % 2 == 0) {
                // On a clear value in the y direction
                result[id.xy] = (image[center.xy] + image[center.xy + uint2(1, 0)]) / 2;
                return;
            }
        }
        if (id.x % 2 == 0) {
            // On a clear value in the x direction
            if (id.y % 2 == 1) {
                // Interpolate between two values in y
                result[id.xy] =(image[center.xy] + image[center.xy + uint2(0, 1)]) / 2;
                return;
            }
            if (id.y % 2 == 0) {
                // On a clear value in the y direction
                result[id.xy] = image[center.xy];
                return;
            }
        }
    }

    if (id.x % 2 == 1) {
        // Interpolate between two values in x
        if (id.y % 2 == 1) {
            // Interpolate between two values in y
            result[id.xy] = (result[id.xy] + (image[center.xy] + image[center.xy + uint2(1, 0)] + image[center.xy + uint2(0, 1)] + image[center.xy + uint2(1, 1)]) / 4) / 2;
            return;
        }
        if (id.y % 2 == 0) {
            // On a clear value in the y direction
            result[id.xy] = (result[id.xy] + (image[center.xy] + image[center.xy + uint2(1, 0)]) / 2) / 2;
            return;
        }
    }
    if (id.x % 2 == 0) {
        // On a clear value in the x direction
        if (id.y % 2 == 1) {
            // Interpolate between two values in y
            result[id.xy] = (result[id.xy] + (image[center.xy] + image[center.xy + uint2(0, 1)]) / 2) / 2;
            return;
        }
        if (id.y % 2 == 0) {
            // On a clear value in the y direction
            result[id.xy] = (result[id.xy] + image[center.xy]) / 2;
            return;
        }
    }
    result[id.xy] = result[id.xy];

}





float applyMask(uint2 pixel) {
    return result[pixel] * (1 - image[pixel].y) + image[pixel].x * image[pixel].y;
}



float FK(uint2 pixel) {
    return 0;
}

float FI(uint2 pixel) {
    return image[pixel];
}

float F(uint2 pixel) {
    float a = image[pixel].y;
    float b = image[pixel].z;

    float result = 0;

    if (a > 0.1) {
        // FL
        result += a * 0.25 * (
            F(pixel - uint2(0, 1)) +
            F(pixel - uint2(1, 0)) +
            F(pixel - uint2(-1, 0)) +
            F(pixel - uint2(0, -1))
            );;
    }
    return result + b * FK(pixel) + (1 - a - b) * FI(pixel);
}

int h;
float x;

[numthreads(8, 8, 1)]
void Relax(uint3 id : SV_DispatchThreadID)
{
    //result[id.xy] = F(id.xy);
    /*
    Works fine but I want something better.
    Using fading mask
    */
    uint2 center = uint2(id.x, id.y);
    result[id.xy] = float4(0.25 * (
        applyMask(center - uint2(0, 1)) +
        applyMask(center - uint2(1, 0)) +
        applyMask(center - uint2(-1, 0)) +
        applyMask(center - uint2(0, -1))
        )
        // Use y as mask
        * (1 - image[id.xy].y) + image[id.xy].x * image[id.xy].y
        ,
        image[id.xy].y, 0, 1)
        ;

}
